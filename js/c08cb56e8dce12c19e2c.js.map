{"version":3,"file":"js/c08cb56e8dce12c19e2c.js","mappings":"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","sources":["webpack://fausteditorweb/./src/monaco-faust/Faust2MD.ts","webpack://fausteditorweb/./src/monaco-faust/Faust2Doc.ts","webpack://fausteditorweb/./src/monaco-faust/FaustLang.ts"],"sourcesContent":["/*\n\nUltra simple automatic documentation system for Faust.\nCreates a markdown file by extracting the comments from\na Faust file. The option -t n can be used to change the\ndefault (4) tab setting. The option -c can be used to\ninclude the Faust code itself into the generated doc.\nAnd the option -f can be used to include a YAML front\nmatter with the name of the file and the date.\n\nThe format of a title is :\n    //############# Title Name #################\n    //  markdown text....\n    //  markdown text....\n    //##########################################\n\nThe format of a section is :\n    //============== Section Name ==============\n    //  markdown text....\n    //  markdown text....\n    //==========================================\n\nThe format of a comment is :\n    //-------------- foo(x,y) ------------------\n    //  markdown text....\n    //  markdown text....\n    //------------------------------------------\neverything else is considered Faust code.\nThe translation is the following:\n  ## foo(x,y)\n    markdown text....\n    markdown text....\n--------------------------------------------------------\n*/\ntype Faust2MDOptions = { tabsize: number; code: boolean; front: boolean };\n/**\n * faust2md ts port\n *\n * @class Faust2MD\n */\nexport class Faust2MD {\n    private static readonly REGEX_BEG_TITLE = /^\\s*\\/\\/#{3,}\\s*([^#]*[^#\\s])\\s*#{3,}$/;\n    private static readonly REGEX_END_TITLE = /^\\s*((\\/\\/#{3,})|(\\s*))$/;\n    private static readonly REGEX_BEG_SECTION = /^\\s*\\/\\/={3,}\\s*([^=]*[^=\\s])\\s*={3,}$/;\n    private static readonly REGEX_END_SECTION = /^\\s*((\\/\\/={3,})|(\\s*))$/;\n    private static readonly REGEX_BEG_COMMENT = /^\\s*\\/\\/-{3,}\\s*([^-]*[^=\\s])\\s*-{3,}$/;\n    private static readonly REGEX_END_COMMENT = /^\\s*((\\/\\/-{3,})|(\\s*))$/;\n    private static readonly REGEX_INDENT = /(^\\s*\\/\\/\\s*)[^\\s]/;\n    private static readonly REGEX_COMMENT = /^\\s*\\/\\//;\n    /**\n     * Print the front matter of the file\n     *\n     * @static\n     * @param {string} fileName\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static frontMatter(fileName: string): string {\n        return \"---\\n\"\n        + `file: ${fileName}\\n`\n        + `date: ${new Date().toLocaleDateString()}\\n`\n        + \"---\\n\";\n    }\n    /**\n     * Outdent a comment line by n characters in\n     * order to remove the prefix \"//   \"\n     *\n     * @static\n     * @param {string} line\n     * @param {number} idt\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static outdent(line: string, idt: number): string {\n        return line.length <= idt ? \"\\n\" : line.substr(idt);\n    }\n    /**\n     * Match the first line of a title\n     * of type \"//#### Title ####\"\n     * at least 3 # are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginTitle(line: string): string {\n        const matched = line.match(this.REGEX_BEG_TITLE);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a title\n     * of type \"//########\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndTitle(line: string): boolean {\n        const matched = line.match(this.REGEX_END_TITLE);\n        return !!matched;\n    }\n    /**\n     * Match the first line of a section\n     * of type \"//==== Section ====\"\n     * at least 3 = are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginSection(line: string): string {\n        const matched = line.match(this.REGEX_BEG_SECTION);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a section\n     * of type \"//=======\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndSection(line: string): boolean {\n        const matched = line.match(this.REGEX_END_SECTION);\n        return !!matched;\n    }\n    /**\n     * Match the first line of a comment\n     * of type \"//--- foo(x,y) ----\"\n     * at least 3 - are needed\n     *\n     * @static\n     * @param {string} line\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchBeginComment(line: string): string {\n        const matched = line.match(this.REGEX_BEG_COMMENT);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Match the last line of a comment\n     * of type \"//-----------------\"\n     * or a blank line\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static matchEndComment(line: string): boolean {\n        const matched = line.match(this.REGEX_END_COMMENT);\n        return !!matched;\n    }\n    /**\n     * Measure the indentation of a md-comment line\n     * that is the len of the prefix '//   '\n     *\n     * @static\n     * @param {string} line\n     * @returns {number}\n     * @memberof Faust2MD\n     */\n    static indentation(line: string): number {\n        const matched = line.match(this.REGEX_INDENT);\n        return matched ? matched[1].length : 0;\n    }\n    /**\n     * Indicates if a line is a comment\n     *\n     * @static\n     * @param {string} line\n     * @returns {boolean}\n     * @memberof Faust2MD\n     */\n    static isComment(line: string): boolean {\n        const matched = line.match(this.REGEX_COMMENT);\n        return !!matched;\n    }\n    /**\n     * Process the file\n     *\n     * @static\n     * @param {string} strIn\n     * @param {string} [fileName]\n     * @param {{ tabsize?: number, code?: boolean, front?: boolean }} [optionsIn]\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static parse(strIn: string, fileName?: string, optionsIn?: { tabsize?: number; code?: boolean; front?: boolean }): string {\n        const options: Faust2MDOptions = { tabsize: 4, code: false, front: false, ...optionsIn };\n        let strOut = \"\";\n        let inComment = false; // false: in code; true: in md-comment\n        let idt = 0; // indentation retained to outdent comment lines\n        if (options.front && fileName) strOut += this.frontMatter(fileName);\n        strIn.split(\"\\n\").forEach((line) => {\n            if (!this.isComment(line)) {\n                if (inComment) { // we are closing a md-comment\n                    strOut += \"\\n\";\n                    inComment = false;\n                }\n                if (options.code) strOut += `\\t${line}\\n`;\n                return;\n            }\n            if (inComment) { // we are in a md-comment\n                if (idt === 0) idt = this.indentation(line); // we have to measure the indentation\n                // check end of md-comment\n                const { endC, endS, endT } = { endC: this.matchEndComment(line), endS: this.matchEndSection(line), endT: this.matchEndTitle(line) };\n                if (endC) strOut += \"\\n---\\n\\n\";\n                if (endC || endS || endT) inComment = false; // end of md-comment switch back to mode O\n                else strOut += this.outdent(line, idt) + \"\\n\";\n                return;\n            }\n            // check begin of md-comment\n            const { c, s, t } = { c: this.matchBeginComment(line), s: this.matchBeginSection(line), t: this.matchBeginTitle(line) };\n            if (c) strOut += `\\n### ${c}\\n`;\n            else if (s) strOut += `\\n## ${s}\\n`;\n            else if (t) strOut += `\\n# ${t}\\n`;\n            if (c || s || t) {\n                inComment = true;\n                idt = 0;\n            } else if (options.code) strOut += `\\t${line}\\n`;\n        });\n        return strOut;\n    }\n}\n","/* eslint-disable no-await-in-loop */\nimport { Faust2MD } from \"./Faust2MD\";\n/*\nRetrive faust2md doc by parsing .dsp file\n\nThe format of a title is :\n    //############# Title Name #################\n    //  markdown text....\n    //  markdown text....\n    //##########################################\n\nThe format of a section is :\n    //============== Section Name ==============\n    //  markdown text....\n    //  markdown text....\n    //==========================================\n\nThe format of a comment is :\n    //-------------- foo(x,y) ------------------\n    //  markdown text....\n    //  markdown text....\n    //------------------------------------------\neverything else is considered Faust code.\n--------------------------------------------------------\n*/\nexport type TFaustDocs = { [key: string]: TFaustDoc };\nexport type TFaustDoc = { path: string[]; name: string; doc: string };\n/**\n *\n * @class Faust2Doc\n */\nexport class Faust2Doc {\n    private static readonly REGEX_DEF_LIB = /\\b(\\w+)\\s*=\\s*library\\(\"(.+)\"\\);/;\n    private static readonly REGEX_DEF_IMP = /\\bimport\\(\"(.+)\"\\);/;\n    private static readonly REGEX_FUNC_NAME = /`.*?([\\w[\\]|]+)`/;\n    private static readonly REGEX_FUNC_NAME_COND = /\\[(.+?)(\\|.+?)*?]/;\n    /**\n     * Retrieve a library definition\n     *\n     * @static\n     * @param {string} line\n     * @returns {{ namespace: string, fileName: string }[]}\n     * @memberof Faust2Doc\n     */\n    static matchLibrary(line: string): { namespace: string; fileName: string }[] {\n        const libs = [] as { namespace: string; fileName: string }[];\n        const exps = line.match(new RegExp(this.REGEX_DEF_LIB, \"g\"));\n        if (exps) {\n            exps.forEach((exp) => {\n                const matched = exp.match(this.REGEX_DEF_LIB);\n                if (matched) libs.push({ namespace: matched[1], fileName: matched[2] });\n            });\n        }\n        return libs;\n    }\n    /**\n     * Retrieve an import expression\n     *\n     * @static\n     * @param {string} line\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    static matchImport(line: string): string[] {\n        const imps = [] as string[];\n        const exps = line.match(new RegExp(this.REGEX_DEF_IMP, \"g\"));\n        if (exps) {\n            exps.forEach((exp) => {\n                const matched = exp.match(this.REGEX_DEF_IMP);\n                if (matched) imps.push(matched[1]);\n            });\n        }\n        return imps;\n    }\n    /**\n     * Retrieve true function name from string in comments\n     * `(si.)bus`\n     *\n     * @static\n     * @param {string} str\n     * @returns {string}\n     * @memberof Faust2MD\n     */\n    static matchFuncName(str: string): string {\n        const matched = str.match(this.REGEX_FUNC_NAME);\n        return matched ? matched[1] : null;\n    }\n    /**\n     * Get all conditions in func name like `[third|half]_octave_[analyzer|filterbank][n]`\n     *\n     * @static\n     * @param {string} str\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    static getAllConditions(str: string): string[] {\n        return this.getCondition([str]);\n    }\n    /**\n     * getAllConditions Recursive body\n     *\n     * @static\n     * @param {string[]} [condsIn]\n     * @param {RegExp} [regexp]\n     * @returns {string[]}\n     * @memberof Faust2Doc\n     */\n    private static getCondition(condsIn?: string[]): string[] {\n        const conds = [] as string[];\n        condsIn.forEach((cond) => {\n            const regexp = new RegExp(this.REGEX_FUNC_NAME_COND, \"g\");\n            const result = regexp.exec(cond);\n            if (!result) return;\n            const found = result[0];\n            const index = result.index;\n            const subConds = result.splice(1).filter(el => typeof el === \"string\").map(str => str.replace(/^\\|/, \"\"));\n            const before = cond.substring(0, index);\n            const after = cond.substring(index + found.length);\n            if (subConds.length === 1) {\n                conds.push(before + after);\n                conds.push(before + subConds + after);\n            } else {\n                subConds.forEach(subCond => conds.push(before + subCond + after));\n            }\n        });\n        return conds.length ? this.getCondition(conds) : condsIn;\n    }\n    /**\n     * Process the file\n     *\n     * @static\n     * @param {string} fileName fileName to be fetch using getFile\n     * @param {string} getFile callback used for import and library expressions\n     * @param {string[]} [depthIn] current Depth, stop when 0;\n     * @param {string[]} [pathIn] path of current namespace\n     * @param {string} [docIn] recursive accum object for output\n     * @returns {Promise<TFaustDocs>}\n     * @memberof Faust2MD\n     */\n    static async parse(fileName: string, getFile: (fileName: string) => Promise<string>, depthIn?: number, pathIn?: string[], docIn?: TFaustDocs): Promise<TFaustDocs> {\n        if (depthIn === 0) return docIn;\n        const depth = depthIn || 2;\n        const strIn = await getFile(fileName);\n        const doc: TFaustDocs = docIn || {};\n        const path = pathIn || [];\n        let inComment = false; // false: in code; true: in md-comment\n        let idt = 0; // indentation retained to outdent comment lines\n        let curName = \"\"; // current function name\n        let strBuffer = \"\"; // current function doc\n        const lines = strIn.split(\"\\n\");\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i];\n            if (!line) continue; // empty line\n            if (!Faust2MD.isComment(line)) {\n                if (inComment) { // we are closing a md-comment\n                    inComment = false;\n                    if (curName) this.getAllConditions(curName).forEach(name => doc[path.concat(name).join(\".\")] = { name: curName, path: [...path], doc: strBuffer });\n                    curName = \"\";\n                    strBuffer = \"\";\n                }\n                const libs = this.matchLibrary(line);\n                const imps = this.matchImport(line);\n                for (let j = 0; j < libs.length; j++) {\n                    const lib = libs[j];\n                    await this.parse(lib.fileName, getFile, depth - 1, [...path, lib.namespace], doc);\n                }\n                for (let j = 0; j < imps.length; j++) {\n                    const imp = imps[j];\n                    await this.parse(imp, getFile, depth - 1, path, doc);\n                }\n                continue;\n            }\n            if (inComment) { // we are in a md-comment (not first line)\n                if (idt === 0) idt = Faust2MD.indentation(line); // we have to measure the indentation\n                // check end of md-comment\n                const { endC, endS, endT } = { endC: Faust2MD.matchEndComment(line), endS: Faust2MD.matchEndSection(line), endT: Faust2MD.matchEndTitle(line) };\n                if (endC || endS || endT) inComment = false; // end of md-comment switch back to mode O\n                else strBuffer += Faust2MD.outdent(line, idt) + \"\\n\";\n                if (endC) { // pop buffer\n                    if (curName) this.getAllConditions(curName).forEach(name => doc[path.concat(name).join(\".\")] = { name: curName, path: [...path], doc: strBuffer });\n                    curName = \"\";\n                    strBuffer = \"\";\n                }\n                continue;\n            }\n            // check begin of md-comment\n            const { c, s, t } = { c: Faust2MD.matchBeginComment(line), s: Faust2MD.matchBeginSection(line), t: Faust2MD.matchBeginTitle(line) };\n            if (c) curName = this.matchFuncName(c);\n            if (c || s || t) {\n                inComment = true;\n                idt = 0;\n                strBuffer = \"\";\n            }\n        }\n        return doc;\n    }\n}\n","import { languages, editor, Position, Range } from \"monaco-editor\";\nimport { LibFaust } from \"@grame/faustwasm\";\nimport { Faust2Doc, TFaustDocs, TFaustDoc } from \"./Faust2Doc\";\n\nimport { docSections, faustDocURL } from \"../documentation\";\n\nexport type FaustLanguageProviders = {\n    hoverProvider: languages.HoverProvider;\n    tokensProvider: languages.IMonarchLanguage;\n    completionItemProvider: languages.CompletionItemProvider;\n    docs: TFaustDocs;\n};\nexport const language: languages.ILanguageExtensionPoint = {\n    id: \"faust\",\n    extensions: [\"dsp\", \"lib\"],\n    mimetypes: [\"application/faust\"]\n};\nexport const config: languages.LanguageConfiguration = {\n    comments: {\n        lineComment: \"//\",\n        blockComment: [\"/*\", \"*/\"]\n    },\n    brackets: [\n        [\"{\", \"}\"],\n        [\"[\", \"]\"],\n        [\"(\", \")\"]\n    ],\n    autoClosingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"', notIn: [\"string\"] },\n        { open: \"/*\", close: \"*/\", notIn: [\"string\"] }\n    ]\n};\nexport const theme: editor.IStandaloneThemeData = {\n    base: \"vs-dark\",\n    inherit: true,\n    rules: [\n        { token: \"faustFunctions\", foreground: \"DDDD99\" },\n        { token: \"faustKeywords\", foreground: \"4499CC\" },\n        { token: \"faustLib\", foreground: \"CCCCBB\" },\n        { token: \"faustCompOperators\", foreground: \"FFDDFF\" },\n        { token: \"identifier\", foreground: \"77CCFF\" }\n    ],\n    colors: {}\n};\nconst faustKeywords = [\n    \"import\", \"component\", \"declare\", \"library\", \"environment\", \"int\", \"float\",\n    \"letrec\", \"with\", \"class\", \"process\", \"effect\", \"inputs\", \"outputs\"\n];\nconst faustFunctions = [\n    \"mem\", \"prefix\", \"rdtable\", \"rwtable\",\n    \"select2\", \"select3\", \"ffunction\", \"fconstant\", \"fvariable\",\n    \"route\", \"waveform\", \"soundfile\",\n    \"button\", \"checkbox\", \"vslider\", \"hslider\", \"nentry\",\n    \"vgroup\", \"hgroup\", \"tgroup\", \"vbargraph\", \"hbargraph\", \"attach\",\n    \"acos\", \"asin\", \"atan\", \"atan2\", \"cos\", \"sin\", \"tan\", \"exp\",\n    \"log\", \"log10\", \"pow\", \"sqrt\", \"abs\", \"min\", \"max\", \"fmod\",\n    \"remainder\", \"floor\", \"ceil\", \"rint\", \"round\",\n    \"seq\", \"par\", \"sum\", \"prod\"\n];\nconst getFile = async (fileName: string, libFaust: LibFaust) => {\n    if (libFaust) return libFaust.fs().readFile(\"/usr/share/faust/\" + fileName, { encoding: \"utf8\" }) as string;\n    const libPath = \"https://faustlibraries.grame.fr/libs/\";\n    const res = await fetch(libPath + fileName);\n    return res.text();\n};\ntype TMatchedFaustDoc = { nameArray: string[]; name: string; range: Range; doc: TFaustDoc };\n/**\n * Match an available doc key from monaco editor\n *\n * @param {TFaustDocs} doc\n * @param {editor.ITextModel} model\n * @param {Position} position\n * @returns {TMatchedFaustDoc} full: [...prefixes, name], range: a monaco range object, doc: a FaustDoc object\n */\nexport const matchDocKey = (doc: TFaustDocs, model: editor.ITextModel, position: Position): TMatchedFaustDoc => {\n    const line$ = position.lineNumber;\n    const line = model.getLineContent(line$);\n    const wordAtPosition = model.getWordAtPosition(position);\n    if (!wordAtPosition) return null;\n    let column$ = wordAtPosition.startColumn - 1;\n    const name = wordAtPosition.word;\n    const prefixes: string[] = [];\n    while (column$ - 2 >= 0 && line[column$ - 1] === \".\") {\n        column$ -= 2;\n        const prefixWord = model.getWordAtPosition(new Position(line$, column$));\n        prefixes.splice(0, 0, prefixWord.word);\n        column$ = prefixWord.startColumn - 1;\n    }\n    const nameArray = [...prefixes, name];\n    while (nameArray.length) {\n        const name = nameArray.join(\".\");\n        const e = doc[name];\n        if (e) {\n            return {\n                nameArray,\n                name,\n                range: new Range(line$, column$ + 1, line$, wordAtPosition.endColumn),\n                doc: e\n            };\n        }\n        column$ += nameArray.splice(0, 1)[0].length + 1;\n    }\n    return null;\n};\nexport const getProviders = async (libFaust: LibFaust): Promise<FaustLanguageProviders> => {\n    let libDocs: TFaustDocs = {};\n    let primDocs: TFaustDocs = {};\n    try {\n        libDocs = await Faust2Doc.parse(\"stdfaust.lib\", async (fileName: string) => getFile(fileName, libFaust));\n        primDocs = await Faust2Doc.parse(\"primitives.lib\", async (fileName: string) => getFile(fileName, libFaust));\n    } catch (e) { console.error(e); } // eslint-disable-line no-empty, no-console\n    const faustLib = Object.keys(libDocs);\n\n    const hoverProvider: languages.HoverProvider = {\n        provideHover: (model, position) => {\n            const matched = matchDocKey({ ...primDocs, ...libDocs }, model, position);\n            if (matched) {\n                const prefix = matched.nameArray.slice();\n                const name = prefix.pop();\n                const doc = matched.doc;\n                return {\n                    range: matched.range,\n                    contents: [\n                        { value: `\\`\\`\\`\\n${prefix.length ? \"(\" + prefix.join(\".\") + \".)\" : \"\"}${name}\\n\\`\\`\\`` },\n                        { value: doc.doc.replace(/#+/g, \"######\") },\n                        { value: prefix.length ? `[Detail...](${faustDocURL}/${docSections[prefix.slice(0, 2).join(\"\")]}/#${prefix.join(\".\")}${doc.name.replace(/[[\\]|]/g, \"\").toLowerCase()})` : \"[Detail...](https://faustdoc.grame.fr/manual/syntax/index.html#faust-syntax)\" }\n                    ]\n                };\n            }\n            return null;\n        }\n    };\n    const tokensProvider: languages.IMonarchLanguage = ({\n        faustKeywords,\n        faustFunctions,\n        faustLib,\n        defaultToken: \"invalid\",\n        tokenPostfix: \".dsp\",\n        faustCompOperators: [\n            \"~\", \",\", \":\", \"<:\", \":>\"\n        ],\n        operators: [\n            \"=\",\n            \"+\", \"-\", \"*\", \"/\", \"%\", \"^\",\n            \"&\", \"|\", \"xor\", \"<<\", \">>\",\n            \">\", \"<\", \"==\", \"<=\", \">=\", \"!=\",\n            \"@\", \"'\"\n        ],\n        // we include these common regular expressions\n        symbols: /[=><!~?:&|+\\-*/^%]+/,\n        // C# style strings\n        escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n        // The main tokenizer for our languages\n        tokenizer: {\n            root: [\n                // identifiers and keywords\n                [/!|_/, \"keyword\"],\n                [/[a-z_$]([\\w.$]*[\\w$])?/, {\n                    cases: {\n                        \"@faustFunctions\": \"faustFunctions\",\n                        \"@faustKeywords\": \"faustKeywords\",\n                        \"@faustLib\": \"faustLib\",\n                        \"@default\": \"identifier\"\n                    }\n                }],\n                [/[A-Z][\\w$]*/, \"type.identifier\"],\n                // whitespace\n                { include: \"@whitespace\" },\n                // delimiters and operators\n                [/[{}()[\\]]/, \"@brackets\"],\n                [/~|,|<:|:>|:/, \"faustCompOperators\"],\n                [/[<>](?!@symbols)/, \"@brackets\"],\n                [/=|\\+|-|\\*|\\/|%|\\^|&|\\||xor|<<|>>|>|<|==|<=|>=|!=|@|'/, {\n                    cases: {\n                        \"@operators\": \"operators\",\n                        \"@default\": \"\"\n                    }\n                }],\n                // numbers\n                [/\\d*\\.\\d+([eE][-+]?\\d+)?/, \"number.float\"],\n                [/0[xX][0-9a-fA-F]+/, \"number.hex\"],\n                [/\\d+/, \"number\"],\n                // delimiter: after number because of .\\d floats\n                [/[;.]/, \"delimiter\"],\n                // strings\n                [/\"/, { token: \"string\", next: \"@string\" }]\n            ],\n            comment: [\n                [/[^/*]+/, \"comment\"],\n                [/\\/\\*/, \"comment\", \"@push\"],\n                [/\\*\\//, \"comment\", \"@pop\"],\n                [/[/*]/, \"comment\"]\n            ],\n            string: [\n                [/[^\\\\\"$]+/, \"string\"],\n                [/@escapes/, \"string.escape\"],\n                [/\\\\./, \"string.escape.invalid\"],\n                [/\"/, \"string\", \"@pop\"]\n            ],\n            whitespace: [\n                [/[ \\t\\r\\n]+/, \"white\"],\n                [/\\/\\*/, \"comment\", \"@comment\"],\n                [/\\/\\/.*$/, \"comment\"]\n            ]\n        }\n    } as any);\n    const completionItemProvider: languages.CompletionItemProvider = {\n        provideCompletionItems: () => {\n            const suggestions: languages.CompletionItem[] = [];\n            [...faustKeywords, ...faustFunctions, ...faustLib].forEach((e) => {\n                suggestions.push({\n                    label: e,\n                    kind: languages.CompletionItemKind.Text,\n                    insertText: e,\n                    range: null\n                });\n            });\n            return { suggestions };\n        }\n    };\n    return { hoverProvider, tokensProvider, completionItemProvider, docs: libDocs };\n};\n"],"names":["Faust2MD","frontMatter","fileName","concat","Date","toLocaleDateString","outdent","line","idt","length","substr","matchBeginTitle","matched","match","this","REGEX_BEG_TITLE","matchEndTitle","REGEX_END_TITLE","matchBeginSection","REGEX_BEG_SECTION","matchEndSection","REGEX_END_SECTION","matchBeginComment","REGEX_BEG_COMMENT","matchEndComment","REGEX_END_COMMENT","indentation","REGEX_INDENT","isComment","REGEX_COMMENT","parse","strIn","optionsIn","options","_objectSpread","tabsize","code","front","strOut","inComment","split","forEach","_endC$endS$endT","endC","endS","endT","_c$s$t","c","s","t","_defineProperty","Faust2Doc","matchLibrary","libs","exps","RegExp","REGEX_DEF_LIB","exp","push","namespace","matchImport","imps","REGEX_DEF_IMP","matchFuncName","str","REGEX_FUNC_NAME","getAllConditions","getCondition","condsIn","conds","cond","result","REGEX_FUNC_NAME_COND","exec","found","index","subConds","splice","filter","el","map","replace","before","substring","after","subCond","getFile","depthIn","pathIn","docIn","_this","_asyncToGenerator","_regeneratorRuntime","_callee","depth","doc","path","curName","strBuffer","lines","i","j","lib","_j","imp","_context","prev","next","abrupt","sent","name","join","stop","language","id","extensions","mimetypes","config","comments","lineComment","blockComment","brackets","autoClosingPairs","open","close","notIn","theme","base","inherit","rules","token","foreground","colors","faustKeywords","faustFunctions","_ref","libFaust","res","fs","readFile","encoding","fetch","text","_x","_x2","apply","arguments","matchDocKey","model","position","line$","lineNumber","getLineContent","wordAtPosition","getWordAtPosition","column$","startColumn","word","prefixes","prefixWord","Position","nameArray","e","range","Range","endColumn","getProviders","_ref2","_callee4","libDocs","primDocs","faustLib","hoverProvider","tokensProvider","completionItemProvider","_context4","_ref3","_callee2","_context2","_x4","_ref4","_callee3","_context3","_x5","t0","console","error","Object","keys","provideHover","prefix","slice","pop","contents","value","faustDocURL","docSections","toLowerCase","defaultToken","tokenPostfix","faustCompOperators","operators","symbols","escapes","tokenizer","root","cases","include","comment","string","whitespace","provideCompletionItems","suggestions","label","kind","languages","CompletionItemKind","Text","insertText","docs","_x3"],"sourceRoot":""}